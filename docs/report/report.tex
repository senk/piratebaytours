\documentclass[12pt,a4paper,ngerman,english]{report}
\usepackage[utf8]{inputenc}
\usepackage[german]{babel}
\usepackage[draft]{todonotes} 
\usepackage{pdfpages}
\usepackage{pdflscape}
\usepackage{rotating}
\usepackage{epstopdf}
\usepackage{cite}
\usepackage{graphicx}
\usepackage{gensymb}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{float}
\usepackage{fancyhdr}
\usepackage{textcomp}
\usepackage[numbers]{natbib}
\usepackage{varioref}
\usepackage{hyperref}
\usepackage[ngerman]{cleveref}
\usepackage{listings}

\usepackage[a4paper, top=30mm, left=30mm, right=30mm, bottom=30mm,headsep=10mm, footskip=12mm]{geometry}
\parindent0pt

%\usepackage[sorting=nyt, backend=biber, style=alphabetic]{biblatex}
%\addbibresource{mybib.bib}

\usepackage[onehalfspacing]{setspace}

\graphicspath{graphics}

\newcommand\tab[1][1cm]{\hspace*{#1}}

\pagestyle{fancy} %eigener Seitenstil
\fancyhf{} %alle Kopf- und Fußzeilenfelder bereinigen
\fancyhead[L]{\small{\leftmark}}

\renewcommand{\headrulewidth}{0.1pt} %obere Trennlinie
\fancyfoot[C]{\thepage} %Seitennummer
\setlength{\headheight}{13.6pt}

%\lstset{language=C++, basicstyle=\ttfamily\footnotesize, showstringspaces=false} %C++ code formatierung
\lstset{language=C++,
	basicstyle=\ttfamily\footnotesize,
	breaklines=true,
	%	literate={\ \ }{{\ }}1, 
	showstringspaces=false,
	keywordstyle=\color{blue}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	commentstyle=\color{green}\ttfamily,
	morecomment=[l][\color{magenta}]{\#}
}

\newenvironment{abstractpage}
{\cleardoublepage\vspace*{\fill}\thispagestyle{empty}}
{\vfill\cleardoublepage}
\newenvironment{abstrac}[1]
{\bigskip\selectlanguage{#1}%
	\begin{center}\bfseries\abstractname\end{center}}
{\par\bigskip}

\begin{document}

%Titlepage
\begin{titlepage}
\begin{center}	
	\Huge{PirateBayTours}
	
	\line(1,0){400} \\
	\textsc{\Large Projekt im Modul Verteilte Informationsysteme WS2016/17}\\
	[10cm]

	{\Large\itshape Jesko Appelfeller \par Robin Naundorf \par Frederik Broer \par Jonas Droste \par  }
	%%{\small Martikelnummer: 65654}
	\vfill

	\large{betreut durch\par
		Prof. Dr.-Ing. Thomas Christian \textsc{Weik}}

	\vfill
	{\large \today\par}

\end{center}
\end{titlepage}


% Abstracts
\newpage
\begin{abstractpage}
	\begin{abstrac}{ngerman}
		\todo[inline]{Abstrakt schreiben}
	\end{abstrac}
	
	\begin{abstrac}{english}
		\todo[inline]{Abstrakt übersetzen}
	\end{abstrac}
\end{abstractpage}



\newpage
\tableofcontents

\chapter{Motivation und Anforderungen}
Im Rahmen des Moduls 'Verteilte Informationssysteme' an der Fachhochschule Münster wird ein Semester begleitendes Datenbank Projekt durchgeführt. Ziel des Projektes ist es, ein Buchungssystem für Bootstouren zu implementieren. Die Firma Pirate-Bay-Tours beschäftigt mehrere Vertriebsmitarbeiter, die an Touristen Hotspots Tickets für Boots"-touren vertreiben. Für diese Mitarbeiter soll ein neues Buchungssystem implementiert werden.\\
Wichtigstes Funktionsmerkmal des Systems ist die Offline-Fähigkeit. Das heißt, auch wenn der Mitarbeiter keine Verbindung zum zentralen Buchungsserver hat, muss die Buchung von Touren möglich sein. Dazu soll eine Replikationslogik entwickelt werden, die offline getätigte Buchungen bei verfügbarer Online-Verbindung mit dem Server synchronisiert. Weiterhin soll ein Quotensystem entwickelt werden, mit dem es möglich ist, verfügbare Tourtickets auf unterschiedliche Agenten zu verteilen. Zusätzlich muss eine Strategie entwickelt werden, wie mit Überbuchungen umgegangen werden soll.
\todo[inline]{Motivation des Projektes\\
	Was waren seine Anforderungen?\\}

\chapter{Lösungskonzept}
\section{Architektur}
\todo[inline]{Aus welchen Komponenten besteht die Software?\\
	Was sind die Schnittstellen?\\}
\section{Backend}
\subsection{Django und Admin Interface}
\todo[inline]{Was bieted Django alles von Hausaus?}
\subsection{Database}
\todo[inline]{Wie ist die Datenbank aufgebaut?\\
	Welche Replikation setzen wir ein?\\
	Wie ist diese Implementiert?\\}
\section{Client}
\subsection{Java Client}
\todo[inline]{Welche Konzepte nutzt der Client? MVC\\
	Wie ist die Struktur im Client?\\
	Welche Klassen wurden implementiert?\\
	Wie erfolgt die Datenhaltung?}
\subsection{Local Cache DB}
Um offline einsatzfähig zu sein, wurde eine lokale SQLite Datenbank genutzt. Während der Synchronisierung vom Server zum Client wird ein Abbild der Serverdatenbank heruntergeladen und in der lokalen Datenbank gecached. Wir haben uns entschieden eine SQLite Datenbank zu nutzen, da keine zusätzlich Datenbankserver installiert werden müssen und alle notwendigen Ressourcen gut in die Applikation eingebunden werden können. Weiterhin wird SQLite von einer Vielzahl an Programmiersprachen gut unterstützt und bietet eine ressourcensparende Möglichkeit Daten abzulegen. \\
Wie erwähnt, enthält die Datenbank nach einmalige Synchronisation ein komplett Abbild der Server-Datenbank. Das heißt, lokal sind folgende Tabellen verfügbar:
\begin{itemize}
	\setlength\itemsep{0.1em}
	\item \texttt{agents}
	\item \texttt{customers}
	\item \texttt{quotas}
	\item \texttt{ships}
	\item \texttt{tours}
\end{itemize}
Zusätzlich dazu werden zwei lokale Tabellen angelegt.
\begin{itemize}
	\setlength\itemsep{0.1em}
	\item \texttt{offline\_bookings}
	\item \texttt{offline\_customers}
\end{itemize}
Die \texttt{offline\_bookings} Tabelle enthält alle Buchungen, die der Vertriebsmitarbeiter im Offline-Fall tätigt. Werden im Offline-Modus neue Kundenstammdaten angelegt werden diese in der Tabelle \texttt{offline\_customers} gespeichert. Dies ist notwendig, um ID Konflikte bei der Replizierung zu vermeiden. Weiterhin lässt sich so mit wenig Aufwand nachvollziehen welche Buchungen noch nicht repliziert wurden. Da das Serverabbild bei einer Offline-Buchung nicht verändert wird, besteht kein Risiko, das es zu inkonsistenten Ausgangsdaten kommt und ein Offline-Arbeiten nicht mehr möglich ist.

\section{Replizierung}
\label{sec:Replizierung}

Wie in \autoref{sec:RepliZeit} beschrieben, gibt es zwei Replikationsprozesse. Zum einen lesend vom Server zur lokalen DB, zum anderen schreibend, von der lokalen DB zum Server.

\subsection{Lesende Replizierung}

Der lesende Replikationsvorgang ist trivial. Die Inhalte der Tabellen \texttt{agents, customers, quotas, ships} und \texttt{tours} werden per HTTP bei der Django-API angefragt und von dieser als JSON zurückgegeben. Clientseitig werden diese JSON-Strings geparst und in die lokale DB eingefügt. \todo[inline]{Verweise auf API Kapitel}

\subsection{Schreibende Replizierung}

Bei der schreibenden Replizierung sollen die Eintrage der Tabellen \texttt{offline\_customers} und \texttt{offline\_bookings} aus der lokalen Datenbank an die Tabellen \texttt{customers} und \texttt{bookings} der zentralen Datenbank übertragen werden. Dies geschiecht, analog zum lesenden Zugriff, durch Umformung der Einträge in JSON-Objekte welche dann mittels HTTP-Requests an eine Django-API geschickt werden.\\

Hierbei ergibt sich die Schwierigkeit, dass die Einträge in der lokalen DB einen automatisch eine ID bekommen haben, die jedoch nur lokal gültig. Bei der Übertragung werden neue, dort gültige IDs für jeden Eintrag vergeben. Dies bedeutet jedoch, dass die Verweise aus der \texttt{offline\_bookings} Tabelle auf IDs in der \texttt{offline\_customers} Tabelle serverseitig nicht mehr gültig sind.\\ \todo[inline]{Verweis auf DB-Schema einfügen}

Es müssen also vor dem Upload der Einträge aus der Tabelle \texttt{offline\_bookings} die Verweise auf die lokalen IDs in der Tabelle \texttt{offline\_customers} ersetzt werden durch Verweise auf die zentralen IDs in der Tabelle \texttt{customers}. Diese werden aber vom Server erst vergeben, wenn die Einträge aus der \texttt{offline\_customers} zum Server gesendet werden. Die bereits erwähnte Django-API beantwortet jeden erfolgreichen Schreibzugriff mit dem Versand des erzeugten Eintrags als JSON-Objekt. Diese Objekte enthalten die vom Server vergebene ID die somit direkt in den entsprechenden Datensatz der lokalen \texttt{offline\_customers} eingetragen werden kann.\\

Es werden jedoch nicht die lokalen IDs überschrieben, sondern die zentralen IDs hinzugefügt. Dies ermöglicht es in einem zweiten Schritt für jeden Eintrag der Tabelle \texttt{offline\_bookings} den Verweis von der lokalen auf die zentrale ID anzupassen und den Eintrag dann zum Server zu senden.\\

Nach Abschluss der Replikation werden die Einträge der Tabellen \texttt{offline\_bookings} und \texttt{offline\_customers} nicht mehr benötigt. Beide Tabellen werden gelöscht und neu angelegt, um Duplikate sicher auszuschließen. Der gesamte Vorgang wird in \autoref{fig:ReplSchreibend} graphisch dargestellt.

\begin{figure}[h]
  \centering
  
  \caption{Ablaufdiagramm schreibende Replikation}
  \label{fig:ReplSchreibend}
\end{figure}
\todo[inline]{Graphik einfügen}

\chapter{Geschäftslogik}
\todo[inline]{Wie werden Fälle wie Überbuchen gehandelt?\\}

\section{Replikationszeitpunkt}
\label{sec:RepliZeit}

Auf Grund der begrenzten Verfügbarkeit von mobilen Internet für unsere mobile Anwendung, wird im Normalfalle nur zu bestimmten Zeitpunkten eine Replizierung von der zentralen Datenbank zur lokalen Datenbank und zurück durchgeführt. Beider Vorgänge werden manuell vom Benutzer ausgelöst. Bei erhöhter Verfügbarkeit des Internets steht es diesem frei häufiger zu replizieren. Minimal wird jedoch davon ausgegangen, dass die Agenten zu Beginn und Ende ihres Arbeitstages Internetzugang haben und folgende Replizierungen durchführen können:\todo[inline]{Muss eine Reihenfolge eingehalten werden?}

\begin{description}
\item[Lesend/Morgens] Zu Beginn des Arbeitstages muss jeder Agent einen Lesevorgang auslösen. Dies geschieht über das GUI mittels der Schaltfläche \todo[inline]{Füge Namen des Buttons ein}. Hierbei werden die Tabellen \texttt{agents, customers, quotas, ships} und \texttt{tours} vom Server heruntergeladen und in die lokale DB eingelesen. Somit verfügt der Agent nach Abschluss des Vorgangs über alle Touren und Schiffe und kann mittels der bereits vorhandenen Buchungen ausrechnen welche Pältze noch frei sind. Er kennt außerdem seine persönlichen Quoten und weiß daher wie viele Pätze er maximal verkaufen kann.
\item[Schreibend/Abends] Am Ende des Arbeitstages muss jeder Agent einen Schreibvorgang auslösen. Dies geschieht über das GUI mittels der Schaltfläche \todo[inline]{Füge Namen des Buttons ein}. Hierbei werden die neu angelegten Kunden und Buchungen aus den Tabellen \texttt{offline\_bookings} und \texttt{offline\_customers} der lokalen DB in die Tabellen \texttt{bookings} und \texttt{customers} der zentralen DB hochgeladen. Der Uploadmechanismus ist in \autoref{sec:Replizierung} beschrieben. Nach Abschluss dieses Vorgangs durch alle Agenten sind dem Server alle neuen Kunden und Buchungen bekannt. 
\end{description}

\chapter{Fazit}
\todo[inline]{Was sind die Lessons Learned\\
	Was könnte man das nächste mal besser machen?\\
	Waren unsere ausgewählten Komponenten für das Problem geeignet?}

\section{Replikation}
\label{sec:FazitRepl}




\bibliography{mybib}{}
\bibliographystyle{plainnat}



\end{document}
