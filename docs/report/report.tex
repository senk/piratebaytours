\documentclass[12pt,a4paper,ngerman,english]{report}
\usepackage[utf8]{inputenc}
\usepackage[german]{babel}
\usepackage[draft]{todonotes} 
\usepackage{pdfpages}
\usepackage{pdflscape}
\usepackage{rotating}
\usepackage{epstopdf}
\usepackage{cite}
\usepackage{graphicx}
\usepackage{gensymb}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{float}
\usepackage{fancyhdr}
\usepackage{textcomp}
\usepackage[numbers]{natbib}
\usepackage{varioref}
\usepackage{hyperref}
\usepackage[ngerman]{cleveref}
\usepackage{listings}

\usepackage[a4paper, top=30mm, left=30mm, right=30mm, bottom=30mm,headsep=10mm, footskip=12mm]{geometry}
\parindent0pt

%\usepackage[sorting=nyt, backend=biber, style=alphabetic]{biblatex}
%\addbibresource{mybib.bib}

\usepackage[onehalfspacing]{setspace}

\graphicspath{graphics}

\newcommand\tab[1][1cm]{\hspace*{#1}}

\pagestyle{fancy} %eigener Seitenstil
\fancyhf{} %alle Kopf- und Fußzeilenfelder bereinigen
\fancyhead[L]{\small{\leftmark}}

\renewcommand{\headrulewidth}{0.1pt} %obere Trennlinie
\fancyfoot[C]{\thepage} %Seitennummer
\setlength{\headheight}{13.6pt}

%\lstset{language=C++, basicstyle=\ttfamily\footnotesize, showstringspaces=false} %C++ code formatierung
\lstset{language=C++,
	basicstyle=\ttfamily\footnotesize,
	breaklines=true,
	%	literate={\ \ }{{\ }}1, 
	showstringspaces=false,
	keywordstyle=\color{blue}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	commentstyle=\color{green}\ttfamily,
	morecomment=[l][\color{magenta}]{\#}
}

\newenvironment{abstractpage}
{\cleardoublepage\vspace*{\fill}\thispagestyle{empty}}
{\vfill\cleardoublepage}
\newenvironment{abstrac}[1]
{\bigskip\selectlanguage{#1}%
	\begin{center}\bfseries\abstractname\end{center}}
{\par\bigskip}

\begin{document}

%Titlepage
\begin{titlepage}
\begin{center}	
	\Huge{PirateBayTours}
	
	\line(1,0){400} \\
	\textsc{\Large Projekt im Modul Verteilte Informationsysteme WS2016/17}\\
	[10cm]

	{\Large\itshape Jesko Appelfeller \par Robin Naundorf \par Frederik Broer \par Jonas Droste \par  }
	%%{\small Martikelnummer: 65654}
	\vfill

	\large{betreut durch\par
		Prof. Dr.-Ing. Thomas Christian \textsc{Weik}}

	\vfill
	{\large \today\par}

\end{center}
\end{titlepage}


% Abstracts
\newpage
\begin{abstractpage}
	\begin{abstrac}{ngerman}
		\todo[inline]{Abstrakt schreiben}
	\end{abstrac}
	
	\begin{abstrac}{english}
		\todo[inline]{Abstrakt übersetzen}
	\end{abstrac}
\end{abstractpage}



\newpage
\tableofcontents

\chapter{Motivation und Anforderungen}
Im Rahmen des Moduls 'Verteilte Informationssysteme' an der Fachhochschule Münster wird ein Semester begleitendes Datenbank Projekt durchgeführt. Ziel des Projektes ist es, ein Buchungssystem für Bootstouren zu implementieren. Die Firma Pirate-Bay-Tours beschäftigt mehrere Vertriebsmitarbeiter, die an Touristen Hotspots Tickets für Boots"-touren vertreiben. Für diese Mitarbeiter soll ein neues Buchungssystem implementiert werden.\\
Wichtigstes Funktionsmerkmal des Systems ist die Offline-Fähigkeit. Das heißt, auch wenn der Mitarbeiter keine Verbindung zum zentralen Buchungsserver hat, muss die Buchung von Touren möglich sein. Dazu soll eine Replikationslogik entwickelt werden, die offline getätigte Buchungen bei verfügbarer Online-Verbindung mit dem Server synchronisiert. Weiterhin soll ein Quotensystem entwickelt werden, mit dem es möglich ist, verfügbare Tourtickets auf unterschiedliche Agenten zu verteilen. Zusätzlich muss eine Strategie entwickelt werden, wie mit Überbuchungen umgegangen werden soll.
\todo[inline]{Motivation des Projektes\\
	Was waren seine Anforderungen?\\}

\chapter{Lösungskonzept}
\section{Architektur}
\todo[inline]{Aus welchen Komponenten besteht die Software?\\
	Was sind die Schnittstellen?\\}
\section{Backend}
\subsection{Django und Admin Interface}
\todo[inline]{Was bieted Django alles von Hausaus?}
\subsection{Database}
\todo[inline]{Wie ist die Datenbank aufgebaut?\\
	Welche Replikation setzen wir ein?\\
	Wie ist diese Implementiert?\\}
\section{Client}
\subsection{Java Client}
\todo[inline]{Welche Konzepte nutzt der Client? MVC\\
	Wie ist die Struktur im Client?\\
	Welche Klassen wurden implementiert?\\
	Wie erfolgt die Datenhaltung?}
\subsection{Local Cache DB}
Um offline einsatzfähig zu sein, wurde eine lokale SQLite Datenbank genutzt. Während der Synchronisierung vom Server zum Client wird ein Abbild der Serverdatenbank heruntergeladen und in der lokalen Datenbank gecached. Wir haben uns entschieden eine SQLite Datenbank zu nutzen, da keine zusätzlich Datenbankserver installiert werden müssen und alle notwendigen Ressourcen gut in die Applikation eingebunden werden können. Weiterhin wird SQLite von einer Vielzahl an Programmiersprachen gut unterstützt und bietet eine ressourcensparende Möglichkeit Daten abzulegen. \\
Wie erwähnt, enthält die Datenbank nach einmalige Synchronisation ein komplett Abbild der Server-Datenbank. Das heißt, lokal sind folgende Tabellen verfügbar:
\begin{itemize}
	\setlength\itemsep{0.1em}
	\item \texttt{agents}
	\item \texttt{customers}
	\item \texttt{quotas}
	\item \texttt{ships}
	\item \texttt{tours}
\end{itemize}
Zusätzlich dazu werden zwei lokale Tabellen angelegt.
\begin{itemize}
	\setlength\itemsep{0.1em}
	\item \texttt{offline\_bookings}
	\item \texttt{offline\_customers}
\end{itemize}
Die \texttt{offline\_bookings} Tabelle enthält alle Buchungen, die der Vertriebsmitarbeiter im Offline-Fall tätigt. Werden im Offline-Modus neue Kundenstammdaten angelegt werden diese in der Tabelle \texttt{offline\_customers} gespeichert. Dies ist notwendig, um ID Konflikte bei der Replizierung zu vermeiden. Weiterhin lässt sich so mit wenig Aufwand nachvollziehen welche Buchungen noch nicht repliziert wurden. Da das Serverabbild bei einer Offline-Buchung nicht verändert wird, besteht kein Risiko, das es zu inkonsistenten Ausgangsdaten kommt und ein Offline-Arbeiten nicht mehr möglich ist.

\section{Replizierung}
\label{sec:Replizierung}

Wie in \autoref{sec:RepliZeit} beschrieben, gibt es zwei Replikationsprozesse. Zum einen lesend vom Server zur lokalen DB, zum anderen schreibend, von der lokalen DB zum Server.

\subsection{Lesende Replizierung}

Der lesende Replikationsvorgang ist trivial. Die Inhalte der Tabellen \texttt{agents, customers, quotas, ships} und \texttt{tours} werden per HTTP bei der Django-API angefragt und von dieser als JSON zurückgegeben. Clientseitig werden diese JSON-Strings geparst und in die lokale DB eingefügt.

\subsection{Schreibende Replizierung}

\chapter{Geschäftslogik}
\todo[inline]{Wie werden Fälle wie Überbuchen gehandelt?\\
	Wie erfolgt die Replizierung von Server zu Client und zurück?\\}

\section{Replikationszeitpunkt}
\label{sec:RepliZeit}

Auf Grund der begrenzten Verfügbarkeit von mobilen Internet für unsere mobile Anwendung, wird im Normalfalle nur zu bestimmten Zeitpunkten eine Replizierung von der zentralen Datenbank zur lokalen Datenbank und zurück durchgeführt. Beider Vorgänge werden manuell vom Benutzer ausgelöst. Bei erhöhter Verfügbarkeit des Internets steht es diesem frei häufiger zu replizieren. Minimal wird jedoch davon ausgegangen, dass die Agenten zu Beginn und Ende ihres Arbeitstages Internetzugang haben und folgende Replizierungen durchführen können:\todo[inline]{Muss eine Reihenfolge eingehalten werden?}

\begin{description}
\item[Lesend/Morgens] Zu Beginn des Arbeitstages muss jeder Agent einen Lesevorgang auslösen. Dies geschieht über das GUI mittels der Schaltfläche \todo[inline]{Füge Namen des Buttons ein}. Hierbei werden die Tabellen \texttt{agents, customers, quotas, ships} und \texttt{tours} vom Server heruntergeladen und in die lokale DB eingelesen. Somit verfügt der Agent nach Abschluss des Vorgangs über alle Touren und Schiffe und kann mittels der bereits vorhandenen Buchungen ausrechnen welche Pältze noch frei sind. Er kennt außerdem seine persönlichen Quoten und weiß daher wie viele Pätze er maximal verkaufen kann.
\item[Schreibend/Abends] Am Ende des Arbeitstages muss jeder Agent einen Schreibvorgang auslösen. Dies geschieht über das GUI mittels der Schaltfläche \todo[inline]{Füge Namen des Buttons ein}. Hierbei werden die neu angelegten Kunden und Buchungen aus den Tabellen \texttt{offline\_bookings} und \texttt{offline\_customers} der lokalen DB in die Tabellen \texttt{bookings} und \texttt{customers} der zentralen DB hochgeladen. Der Uploadmechanismus ist in \autoref{sec:Replizierung} beschrieben. Nach Abschluss dieses Vorgangs durch alle Agenten sind dem Server alle neuen Kunden und Buchungen bekannt. 
\end{description}

\chapter{Fazit}
\todo[inline]{Was sind die Lessons Learned\\
	Was könnte man das nächste mal besser machen?\\
	Waren unsere ausgewählten Komponenten für das Problem geeignet?}


\bibliography{mybib}{}
\bibliographystyle{plainnat}



\end{document}
